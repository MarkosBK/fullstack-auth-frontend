/**
 * Generated by orval v7.13.0 ðŸº
 * Do not edit manually.
 * Fullstack Auth API
 * Complete authentication and user management API for web and mobile applications. Supports JWT authentication, role-based access control, and user management with caching.
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AccountResponseSchema,
  ApiErrorSchema,
  ConflictErrorSchema,
  CreateAccountDto,
  DeleteAccount200,
  ListAccountsParams,
  NotFoundErrorSchema,
  PaginatedAccountsResponseSchema,
  UpdateAccountDto,
  ValidationErrorSchema,
} from '.././schemas';

import { customInstance } from '../../mutator';

/**
 * @summary List accounts with pagination
 */
export const listAccounts = (params?: ListAccountsParams, signal?: AbortSignal) => {
  return customInstance<PaginatedAccountsResponseSchema>({
    url: `/v1/accounts`,
    method: 'GET',
    params,
    signal,
  });
};

export const getListAccountsQueryKey = (params?: ListAccountsParams) => {
  return [`/v1/accounts`, ...(params ? [params] : [])] as const;
};

export const getListAccountsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof listAccounts>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListAccountsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAccounts>>> = ({ signal }) =>
    listAccounts(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof listAccounts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListAccountsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listAccounts>>>;
export type ListAccountsInfiniteQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useListAccountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listAccounts>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params: undefined | ListAccountsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccounts>>,
          TError,
          Awaited<ReturnType<typeof listAccounts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListAccountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listAccounts>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccounts>>,
          TError,
          Awaited<ReturnType<typeof listAccounts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListAccountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listAccounts>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List accounts with pagination
 */

export function useListAccountsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listAccounts>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListAccountsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getListAccountsQueryOptions = <
  TData = Awaited<ReturnType<typeof listAccounts>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListAccountsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listAccounts>>> = ({ signal }) =>
    listAccounts(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listAccounts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof listAccounts>>>;
export type ListAccountsQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useListAccounts<
  TData = Awaited<ReturnType<typeof listAccounts>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params: undefined | ListAccountsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccounts>>,
          TError,
          Awaited<ReturnType<typeof listAccounts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListAccounts<
  TData = Awaited<ReturnType<typeof listAccounts>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAccounts>>,
          TError,
          Awaited<ReturnType<typeof listAccounts>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListAccounts<
  TData = Awaited<ReturnType<typeof listAccounts>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List accounts with pagination
 */

export function useListAccounts<
  TData = Awaited<ReturnType<typeof listAccounts>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListAccountsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listAccounts>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListAccountsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new account
 */
export const createAccount = (createAccountDto: CreateAccountDto, signal?: AbortSignal) => {
  return customInstance<AccountResponseSchema>({
    url: `/v1/accounts`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createAccountDto,
    signal,
  });
};

export const getCreateAccountMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAccount>>,
    TError,
    { data: CreateAccountDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAccount>>,
  TError,
  { data: CreateAccountDto },
  TContext
> => {
  const mutationKey = ['createAccount'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAccount>>,
    { data: CreateAccountDto }
  > = (props) => {
    const { data } = props ?? {};

    return createAccount(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAccountMutationResult = NonNullable<Awaited<ReturnType<typeof createAccount>>>;
export type CreateAccountMutationBody = CreateAccountDto;
export type CreateAccountMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Create a new account
 */
export const useCreateAccount = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAccount>>,
      TError,
      { data: CreateAccountDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createAccount>>,
  TError,
  { data: CreateAccountDto },
  TContext
> => {
  const mutationOptions = getCreateAccountMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get account by ID
 */
export const getAccount = (id: string, signal?: AbortSignal) => {
  return customInstance<AccountResponseSchema>({
    url: `/v1/accounts/${id}`,
    method: 'GET',
    signal,
  });
};

export const getGetAccountQueryKey = (id?: string) => {
  return [`/v1/accounts/${id}`] as const;
};

export const getGetAccountInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAccount>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccount>>> = ({ signal }) =>
    getAccount(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAccount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAccount>>>;
export type GetAccountInfiniteQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useGetAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAccount>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccount>>,
          TError,
          Awaited<ReturnType<typeof getAccount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAccount>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccount>>,
          TError,
          Awaited<ReturnType<typeof getAccount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAccount>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get account by ID
 */

export function useGetAccountInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAccount>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAccountQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccount>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccountQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccount>>> = ({ signal }) =>
    getAccount(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getAccount>>>;
export type GetAccountQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useGetAccount<
  TData = Awaited<ReturnType<typeof getAccount>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccount>>,
          TError,
          Awaited<ReturnType<typeof getAccount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccount<
  TData = Awaited<ReturnType<typeof getAccount>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAccount>>,
          TError,
          Awaited<ReturnType<typeof getAccount>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAccount<
  TData = Awaited<ReturnType<typeof getAccount>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get account by ID
 */

export function useGetAccount<
  TData = Awaited<ReturnType<typeof getAccount>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccount>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAccountQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update account by ID
 */
export const updateAccount = (id: string, updateAccountDto: UpdateAccountDto) => {
  return customInstance<AccountResponseSchema>({
    url: `/v1/accounts/${id}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateAccountDto,
  });
};

export const getUpdateAccountMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAccount>>,
    TError,
    { id: string; data: UpdateAccountDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAccount>>,
  TError,
  { id: string; data: UpdateAccountDto },
  TContext
> => {
  const mutationKey = ['updateAccount'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAccount>>,
    { id: string; data: UpdateAccountDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateAccount(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAccountMutationResult = NonNullable<Awaited<ReturnType<typeof updateAccount>>>;
export type UpdateAccountMutationBody = UpdateAccountDto;
export type UpdateAccountMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Update account by ID
 */
export const useUpdateAccount = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAccount>>,
      TError,
      { id: string; data: UpdateAccountDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAccount>>,
  TError,
  { id: string; data: UpdateAccountDto },
  TContext
> => {
  const mutationOptions = getUpdateAccountMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete account by ID
 */
export const deleteAccount = (id: string) => {
  return customInstance<DeleteAccount200>({ url: `/v1/accounts/${id}`, method: 'DELETE' });
};

export const getDeleteAccountMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAccount>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAccount>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteAccount'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAccount>>, { id: string }> = (
    props
  ) => {
    const { id } = props ?? {};

    return deleteAccount(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAccountMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAccount>>>;

export type DeleteAccountMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Delete account by ID
 */
export const useDeleteAccount = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAccount>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAccount>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteAccountMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
