/**
 * Generated by orval v7.13.0 ðŸº
 * Do not edit manually.
 * Fullstack Auth API
 * Complete authentication and user management API for web and mobile applications. Supports JWT authentication, role-based access control, and user management with caching.
 * OpenAPI spec version: 1.0
 */
import { useMutation } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from '@tanstack/react-query';

import type {
  ApiErrorSchema,
  AuthSuccessResponseSchema,
  BaseSuccessResponseSchema,
  ConflictErrorSchema,
  NotFoundErrorSchema,
  RefreshTokenDto,
  RefreshTokenResponseSchema,
  ResetPasswordDataSchema,
  ResetPasswordDto,
  ResetPasswordRequestDto,
  ResetPasswordResponseSchema,
  ResetPasswordVerifyDto,
  ResetPasswordVerifyResponseSchema,
  SignInDto,
  SignUpDto,
  SignUpResendDto,
  SignUpResponseSchema,
  SignUpVerifyDto,
  ValidationErrorSchema,
} from '.././schemas';

import { customInstance } from '../../mutator';

/**
 * @summary Register a new user
 */
export const signUp = (signUpDto: SignUpDto, signal?: AbortSignal) => {
  return customInstance<SignUpResponseSchema>({
    url: `/v1/auth/sign-up`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: signUpDto,
    signal,
  });
};

export const getSignUpMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUp>>,
    TError,
    { data: SignUpDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signUp>>,
  TError,
  { data: SignUpDto },
  TContext
> => {
  const mutationKey = ['signUp'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signUp>>, { data: SignUpDto }> = (
    props
  ) => {
    const { data } = props ?? {};

    return signUp(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignUpMutationResult = NonNullable<Awaited<ReturnType<typeof signUp>>>;
export type SignUpMutationBody = SignUpDto;
export type SignUpMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Register a new user
 */
export const useSignUp = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signUp>>,
      TError,
      { data: SignUpDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof signUp>>, TError, { data: SignUpDto }, TContext> => {
  const mutationOptions = getSignUpMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Verify registration OTP or resend if needed
 */
export const signUpVerify = (signUpVerifyDto: SignUpVerifyDto, signal?: AbortSignal) => {
  return customInstance<AuthSuccessResponseSchema>({
    url: `/v1/auth/sign-up/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: signUpVerifyDto,
    signal,
  });
};

export const getSignUpVerifyMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUpVerify>>,
    TError,
    { data: SignUpVerifyDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signUpVerify>>,
  TError,
  { data: SignUpVerifyDto },
  TContext
> => {
  const mutationKey = ['signUpVerify'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signUpVerify>>,
    { data: SignUpVerifyDto }
  > = (props) => {
    const { data } = props ?? {};

    return signUpVerify(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignUpVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof signUpVerify>>>;
export type SignUpVerifyMutationBody = SignUpVerifyDto;
export type SignUpVerifyMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Verify registration OTP or resend if needed
 */
export const useSignUpVerify = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signUpVerify>>,
      TError,
      { data: SignUpVerifyDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof signUpVerify>>,
  TError,
  { data: SignUpVerifyDto },
  TContext
> => {
  const mutationOptions = getSignUpVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Resend registration OTP
 */
export const signUpResend = (signUpResendDto: SignUpResendDto, signal?: AbortSignal) => {
  return customInstance<SignUpResponseSchema>({
    url: `/v1/auth/sign-up/resend-otp`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: signUpResendDto,
    signal,
  });
};

export const getSignUpResendMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUpResend>>,
    TError,
    { data: SignUpResendDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signUpResend>>,
  TError,
  { data: SignUpResendDto },
  TContext
> => {
  const mutationKey = ['signUpResend'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signUpResend>>,
    { data: SignUpResendDto }
  > = (props) => {
    const { data } = props ?? {};

    return signUpResend(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignUpResendMutationResult = NonNullable<Awaited<ReturnType<typeof signUpResend>>>;
export type SignUpResendMutationBody = SignUpResendDto;
export type SignUpResendMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Resend registration OTP
 */
export const useSignUpResend = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signUpResend>>,
      TError,
      { data: SignUpResendDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof signUpResend>>,
  TError,
  { data: SignUpResendDto },
  TContext
> => {
  const mutationOptions = getSignUpResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Login user
 */
export const signIn = (signInDto: SignInDto, signal?: AbortSignal) => {
  return customInstance<AuthSuccessResponseSchema>({
    url: `/v1/auth/sign-in`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: signInDto,
    signal,
  });
};

export const getSignInMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signIn>>,
    TError,
    { data: SignInDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signIn>>,
  TError,
  { data: SignInDto },
  TContext
> => {
  const mutationKey = ['signIn'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof signIn>>, { data: SignInDto }> = (
    props
  ) => {
    const { data } = props ?? {};

    return signIn(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignInMutationResult = NonNullable<Awaited<ReturnType<typeof signIn>>>;
export type SignInMutationBody = SignInDto;
export type SignInMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Login user
 */
export const useSignIn = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signIn>>,
      TError,
      { data: SignInDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof signIn>>, TError, { data: SignInDto }, TContext> => {
  const mutationOptions = getSignInMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Refresh access token
 */
export const refresh = (refreshTokenDto: RefreshTokenDto, signal?: AbortSignal) => {
  return customInstance<RefreshTokenResponseSchema>({
    url: `/v1/auth/refresh`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: refreshTokenDto,
    signal,
  });
};

export const getRefreshMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    { data: RefreshTokenDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const mutationKey = ['refresh'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refresh>>,
    { data: RefreshTokenDto }
  > = (props) => {
    const { data } = props ?? {};

    return refresh(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>;
export type RefreshMutationBody = RefreshTokenDto;
export type RefreshMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Refresh access token
 */
export const useRefresh = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refresh>>,
      TError,
      { data: RefreshTokenDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const mutationOptions = getRefreshMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Logout user
 */
export const logout = (signal?: AbortSignal) => {
  return customInstance<BaseSuccessResponseSchema>({
    url: `/v1/auth/logout`,
    method: 'POST',
    signal,
  });
};

export const getLogoutMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationKey = ['logout'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
    return logout();
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Logout user
 */
export const useLogout = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Request password reset OTP
 */
export const resetPasswordRequest = (
  resetPasswordRequestDto: ResetPasswordRequestDto,
  signal?: AbortSignal
) => {
  return customInstance<ResetPasswordResponseSchema>({
    url: `/v1/auth/reset-password/request`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: resetPasswordRequestDto,
    signal,
  });
};

export const getResetPasswordRequestMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPasswordRequest>>,
    TError,
    { data: ResetPasswordRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetPasswordRequest>>,
  TError,
  { data: ResetPasswordRequestDto },
  TContext
> => {
  const mutationKey = ['resetPasswordRequest'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPasswordRequest>>,
    { data: ResetPasswordRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return resetPasswordRequest(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetPasswordRequestMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetPasswordRequest>>
>;
export type ResetPasswordRequestMutationBody = ResetPasswordRequestDto;
export type ResetPasswordRequestMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Request password reset OTP
 */
export const useResetPasswordRequest = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetPasswordRequest>>,
      TError,
      { data: ResetPasswordRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetPasswordRequest>>,
  TError,
  { data: ResetPasswordRequestDto },
  TContext
> => {
  const mutationOptions = getResetPasswordRequestMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Resend password reset OTP
 */
export const resetPasswordResend = (
  resetPasswordRequestDto: ResetPasswordRequestDto,
  signal?: AbortSignal
) => {
  return customInstance<ResetPasswordResponseSchema>({
    url: `/v1/auth/reset-password/resend-otp`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: resetPasswordRequestDto,
    signal,
  });
};

export const getResetPasswordResendMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPasswordResend>>,
    TError,
    { data: ResetPasswordRequestDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetPasswordResend>>,
  TError,
  { data: ResetPasswordRequestDto },
  TContext
> => {
  const mutationKey = ['resetPasswordResend'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPasswordResend>>,
    { data: ResetPasswordRequestDto }
  > = (props) => {
    const { data } = props ?? {};

    return resetPasswordResend(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetPasswordResendMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetPasswordResend>>
>;
export type ResetPasswordResendMutationBody = ResetPasswordRequestDto;
export type ResetPasswordResendMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Resend password reset OTP
 */
export const useResetPasswordResend = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetPasswordResend>>,
      TError,
      { data: ResetPasswordRequestDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetPasswordResend>>,
  TError,
  { data: ResetPasswordRequestDto },
  TContext
> => {
  const mutationOptions = getResetPasswordResendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Reset password with OTP
 */
export const resetPasswordVerify = (
  resetPasswordVerifyDto: ResetPasswordVerifyDto,
  signal?: AbortSignal
) => {
  return customInstance<ResetPasswordVerifyResponseSchema>({
    url: `/v1/auth/reset-password/verify`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: resetPasswordVerifyDto,
    signal,
  });
};

export const getResetPasswordVerifyMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPasswordVerify>>,
    TError,
    { data: ResetPasswordVerifyDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetPasswordVerify>>,
  TError,
  { data: ResetPasswordVerifyDto },
  TContext
> => {
  const mutationKey = ['resetPasswordVerify'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPasswordVerify>>,
    { data: ResetPasswordVerifyDto }
  > = (props) => {
    const { data } = props ?? {};

    return resetPasswordVerify(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetPasswordVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetPasswordVerify>>
>;
export type ResetPasswordVerifyMutationBody = ResetPasswordVerifyDto;
export type ResetPasswordVerifyMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Reset password with OTP
 */
export const useResetPasswordVerify = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetPasswordVerify>>,
      TError,
      { data: ResetPasswordVerifyDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetPasswordVerify>>,
  TError,
  { data: ResetPasswordVerifyDto },
  TContext
> => {
  const mutationOptions = getResetPasswordVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Change password
 */
export const resetPassword = (resetPasswordDto: ResetPasswordDto, signal?: AbortSignal) => {
  return customInstance<ResetPasswordDataSchema>({
    url: `/v1/auth/reset-password`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: resetPasswordDto,
    signal,
  });
};

export const getResetPasswordMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPassword>>,
    TError,
    { data: ResetPasswordDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetPassword>>,
  TError,
  { data: ResetPasswordDto },
  TContext
> => {
  const mutationKey = ['resetPassword'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPassword>>,
    { data: ResetPasswordDto }
  > = (props) => {
    const { data } = props ?? {};

    return resetPassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>;
export type ResetPasswordMutationBody = ResetPasswordDto;
export type ResetPasswordMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Change password
 */
export const useResetPassword = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetPassword>>,
      TError,
      { data: ResetPasswordDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetPassword>>,
  TError,
  { data: ResetPasswordDto },
  TContext
> => {
  const mutationOptions = getResetPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
