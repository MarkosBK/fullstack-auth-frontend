/**
 * Generated by orval v7.13.0 ðŸº
 * Do not edit manually.
 * Fullstack Auth API
 * Complete authentication and user management API for web and mobile applications. Supports JWT authentication, role-based access control, and user management with caching.
 * OpenAPI spec version: 1.0
 */
import { useMutation } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from '@tanstack/react-query';

import type {
  ApiErrorSchema,
  AuthSuccessResponseSchema,
  BaseSuccessResponseSchema,
  ConflictErrorSchema,
  LoginDto,
  NotFoundErrorSchema,
  RefreshTokenDto,
  RefreshTokenResponseSchema,
  RegisterDto,
  ValidationErrorSchema,
} from '.././schemas';

import { customInstance } from '../../mutator';

/**
 * @summary Register a new user
 */
export const register = (registerDto: RegisterDto, signal?: AbortSignal) => {
  return customInstance<AuthSuccessResponseSchema>({
    url: `/v1/auth/register`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: registerDto,
    signal,
  });
};

export const getRegisterMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: RegisterDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterDto },
  TContext
> => {
  const mutationKey = ['register'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: RegisterDto }
  > = (props) => {
    const { data } = props ?? {};

    return register(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<Awaited<ReturnType<typeof register>>>;
export type RegisterMutationBody = RegisterDto;
export type RegisterMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Register a new user
 */
export const useRegister = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register>>,
      TError,
      { data: RegisterDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: RegisterDto },
  TContext
> => {
  const mutationOptions = getRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Login user
 */
export const login = (loginDto: LoginDto, signal?: AbortSignal) => {
  return customInstance<AuthSuccessResponseSchema>({
    url: `/v1/auth/login`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: loginDto,
    signal,
  });
};

export const getLoginMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: LoginDto },
    TContext
  >;
}): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError, { data: LoginDto }, TContext> => {
  const mutationKey = ['login'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, { data: LoginDto }> = (
    props
  ) => {
    const { data } = props ?? {};

    return login(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>;
export type LoginMutationBody = LoginDto;
export type LoginMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Login user
 */
export const useLogin = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { data: LoginDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof login>>, TError, { data: LoginDto }, TContext> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Refresh access token
 */
export const refresh = (refreshTokenDto: RefreshTokenDto, signal?: AbortSignal) => {
  return customInstance<RefreshTokenResponseSchema>({
    url: `/v1/auth/refresh`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: refreshTokenDto,
    signal,
  });
};

export const getRefreshMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refresh>>,
    TError,
    { data: RefreshTokenDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const mutationKey = ['refresh'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refresh>>,
    { data: RefreshTokenDto }
  > = (props) => {
    const { data } = props ?? {};

    return refresh(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshMutationResult = NonNullable<Awaited<ReturnType<typeof refresh>>>;
export type RefreshMutationBody = RefreshTokenDto;
export type RefreshMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Refresh access token
 */
export const useRefresh = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refresh>>,
      TError,
      { data: RefreshTokenDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refresh>>,
  TError,
  { data: RefreshTokenDto },
  TContext
> => {
  const mutationOptions = getRefreshMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Logout user
 */
export const logout = (signal?: AbortSignal) => {
  return customInstance<BaseSuccessResponseSchema>({
    url: `/v1/auth/logout`,
    method: 'POST',
    signal,
  });
};

export const getLogoutMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationKey = ['logout'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
    return logout();
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>;

export type LogoutMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Logout user
 */
export const useLogout = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError, void, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof logout>>, TError, void, TContext> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Request password reset
 */
export const forgotPassword = (signal?: AbortSignal) => {
  return customInstance<BaseSuccessResponseSchema>({
    url: `/v1/auth/forgot-password`,
    method: 'POST',
    signal,
  });
};

export const getForgotPasswordMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof forgotPassword>>, TError, void, TContext> => {
  const mutationKey = ['forgotPassword'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof forgotPassword>>, void> = () => {
    return forgotPassword();
  };

  return { mutationFn, ...mutationOptions };
};

export type ForgotPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof forgotPassword>>>;

export type ForgotPasswordMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Request password reset
 */
export const useForgotPassword = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof forgotPassword>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof forgotPassword>>, TError, void, TContext> => {
  const mutationOptions = getForgotPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Reset password with token
 */
export const resetPassword = (signal?: AbortSignal) => {
  return customInstance<BaseSuccessResponseSchema>({
    url: `/v1/auth/reset-password`,
    method: 'POST',
    signal,
  });
};

export const getResetPasswordMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof resetPassword>>, TError, void, TContext> => {
  const mutationKey = ['resetPassword'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetPassword>>, void> = () => {
    return resetPassword();
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>;

export type ResetPasswordMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Reset password with token
 */
export const useResetPassword = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetPassword>>,
      TError,
      void,
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof resetPassword>>, TError, void, TContext> => {
  const mutationOptions = getResetPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Verify email with token
 */
export const verifyEmail = (signal?: AbortSignal) => {
  return customInstance<BaseSuccessResponseSchema>({
    url: `/v1/auth/verify-email`,
    method: 'POST',
    signal,
  });
};

export const getVerifyEmailMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, void, TContext> => {
  const mutationKey = ['verifyEmail'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyEmail>>, void> = () => {
    return verifyEmail();
  };

  return { mutationFn, ...mutationOptions };
};

export type VerifyEmailMutationResult = NonNullable<Awaited<ReturnType<typeof verifyEmail>>>;

export type VerifyEmailMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Verify email with token
 */
export const useVerifyEmail = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof verifyEmail>>, TError, void, TContext>;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof verifyEmail>>, TError, void, TContext> => {
  const mutationOptions = getVerifyEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
