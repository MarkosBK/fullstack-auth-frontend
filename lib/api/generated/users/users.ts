/**
 * Generated by orval v7.13.0 ðŸº
 * Do not edit manually.
 * Fullstack Auth API
 * Complete authentication and user management API for web and mobile applications. Supports JWT authentication, role-based access control, and user management with caching.
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  ApiErrorSchema,
  ConflictErrorSchema,
  CreateUserDto,
  DeleteUser200,
  ListUsersParams,
  NotFoundErrorSchema,
  PaginatedUsersResponseSchema,
  UpdateUserDto,
  UserControllerAdminOnlyEndpoint200,
  UserResponseSchema,
  ValidationErrorSchema,
} from '.././schemas';

import { customInstance } from '../../mutator';

/**
 * @summary Get current user profile
 */
export const getMe = (signal?: AbortSignal) => {
  return customInstance<UserResponseSchema>({ url: `/v1/users/me`, method: 'GET', signal });
};

export const getGetMeQueryKey = () => {
  return [`/v1/users/me`] as const;
};

export const getGetMeInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMeInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>;
export type GetMeInfiniteQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get current user profile
 */

export function useGetMeInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getMe>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMeInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getMe>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({ signal }) => getMe(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>;
export type GetMeQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get current user profile
 */

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>> },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update current user profile
 */
export const updateMe = (updateUserDto: UpdateUserDto) => {
  return customInstance<UserResponseSchema>({
    url: `/v1/users/me`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateUserDto,
  });
};

export const getUpdateMeMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMe>>,
    TError,
    { data: UpdateUserDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMe>>,
  TError,
  { data: UpdateUserDto },
  TContext
> => {
  const mutationKey = ['updateMe'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMe>>,
    { data: UpdateUserDto }
  > = (props) => {
    const { data } = props ?? {};

    return updateMe(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMeMutationResult = NonNullable<Awaited<ReturnType<typeof updateMe>>>;
export type UpdateMeMutationBody = UpdateUserDto;
export type UpdateMeMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Update current user profile
 */
export const useUpdateMe = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMe>>,
      TError,
      { data: UpdateUserDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMe>>,
  TError,
  { data: UpdateUserDto },
  TContext
> => {
  const mutationOptions = getUpdateMeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary List users with pagination
 */
export const listUsers = (params?: ListUsersParams, signal?: AbortSignal) => {
  return customInstance<PaginatedUsersResponseSchema>({
    url: `/v1/users`,
    method: 'GET',
    params,
    signal,
  });
};

export const getListUsersQueryKey = (params?: ListUsersParams) => {
  return [`/v1/users`, ...(params ? [params] : [])] as const;
};

export const getListUsersInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof listUsers>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({ signal }) =>
    listUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListUsersInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof listUsers>>>;
export type ListUsersInfiniteQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useListUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listUsers>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params: undefined | ListUsersParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listUsers>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listUsers>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List users with pagination
 */

export function useListUsersInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listUsers>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListUsersInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getListUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListUsersQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsers>>> = ({ signal }) =>
    listUsers(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listUsers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof listUsers>>>;
export type ListUsersQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params: undefined | ListUsersParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsers>>,
          TError,
          Awaited<ReturnType<typeof listUsers>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List users with pagination
 */

export function useListUsers<
  TData = Awaited<ReturnType<typeof listUsers>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  params?: ListUsersParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsers>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListUsersQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new user
 */
export const createUser = (createUserDto: CreateUserDto, signal?: AbortSignal) => {
  return customInstance<UserResponseSchema>({
    url: `/v1/users`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createUserDto,
    signal,
  });
};

export const getCreateUserMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: CreateUserDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserDto },
  TContext
> => {
  const mutationKey = ['createUser'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: CreateUserDto }
  > = (props) => {
    const { data } = props ?? {};

    return createUser(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>;
export type CreateUserMutationBody = CreateUserDto;
export type CreateUserMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Create a new user
 */
export const useCreateUser = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: CreateUserDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: CreateUserDto },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Admin only endpoint (example)
 */
export const userControllerAdminOnlyEndpoint = (signal?: AbortSignal) => {
  return customInstance<UserControllerAdminOnlyEndpoint200>({
    url: `/v1/users/admin-only`,
    method: 'GET',
    signal,
  });
};

export const getUserControllerAdminOnlyEndpointQueryKey = () => {
  return [`/v1/users/admin-only`] as const;
};

export const getUserControllerAdminOnlyEndpointInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(options?: {
  query?: Partial<
    UseInfiniteQueryOptions<
      Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerAdminOnlyEndpointQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>> = ({
    signal,
  }) => userControllerAdminOnlyEndpoint(signal);

  return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerAdminOnlyEndpointInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>
>;
export type UserControllerAdminOnlyEndpointInfiniteQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useUserControllerAdminOnlyEndpointInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options: {
    query: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerAdminOnlyEndpointInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerAdminOnlyEndpointInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Admin only endpoint (example)
 */

export function useUserControllerAdminOnlyEndpointInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerAdminOnlyEndpointInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserControllerAdminOnlyEndpointQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerAdminOnlyEndpointQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>> = ({
    signal,
  }) => userControllerAdminOnlyEndpoint(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerAdminOnlyEndpointQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>
>;
export type UserControllerAdminOnlyEndpointQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useUserControllerAdminOnlyEndpoint<
  TData = Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerAdminOnlyEndpoint<
  TData = Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
          TError,
          Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerAdminOnlyEndpoint<
  TData = Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Admin only endpoint (example)
 */

export function useUserControllerAdminOnlyEndpoint<
  TData = Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerAdminOnlyEndpoint>>, TError, TData>
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerAdminOnlyEndpointQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user by ID
 */
export const getUser = (id: string, signal?: AbortSignal) => {
  return customInstance<UserResponseSchema>({ url: `/v1/users/${id}`, method: 'GET', signal });
};

export const getGetUserQueryKey = (id?: string) => {
  return [`/v1/users/${id}`] as const;
};

export const getGetUserInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) =>
    getUser(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type GetUserInfiniteQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useGetUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get user by ID
 */

export function useGetUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) =>
    getUser(id, signal);

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type GetUserQueryError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get user by ID
 */

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update user by ID
 */
export const updateUser = (id: string, updateUserDto: UpdateUserDto) => {
  return customInstance<UserResponseSchema>({
    url: `/v1/users/${id}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateUserDto,
  });
};

export const getUpdateUserMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { id: string; data: UpdateUserDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserDto },
  TContext
> => {
  const mutationKey = ['updateUser'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { id: string; data: UpdateUserDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateUser(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>;
export type UpdateUserMutationBody = UpdateUserDto;
export type UpdateUserMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Update user by ID
 */
export const useUpdateUser = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { id: string; data: UpdateUserDto },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { id: string; data: UpdateUserDto },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete user by ID
 */
export const deleteUser = (id: string) => {
  return customInstance<DeleteUser200>({ url: `/v1/users/${id}`, method: 'DELETE' });
};

export const getDeleteUserMutationOptions = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { id: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteUser'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, { id: string }> = (
    props
  ) => {
    const { id } = props ?? {};

    return deleteUser(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>;

export type DeleteUserMutationError =
  | ValidationErrorSchema
  | ApiErrorSchema
  | ApiErrorSchema
  | NotFoundErrorSchema
  | ConflictErrorSchema;

/**
 * @summary Delete user by ID
 */
export const useDeleteUser = <
  TError =
    | ValidationErrorSchema
    | ApiErrorSchema
    | ApiErrorSchema
    | NotFoundErrorSchema
    | ConflictErrorSchema,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { id: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<typeof deleteUser>>, TError, { id: string }, TContext> => {
  const mutationOptions = getDeleteUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
